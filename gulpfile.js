/**
* !!! DO NOT EDIT THIS FILE DIRECTLY !!!
* ! This file has been generated automatically. See the config/*.js version of
* ! this file to make permanent modifications!
*/

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = exports.wpdevserv = exports.cleanBuild = exports.cleanTypes = exports.regenerate = void 0;

require("source-map-support/register");

var _fs = require("fs");

var _util = require("util");

var _gulp = _interopRequireDefault(require("gulp"));

var _gulpTap = _interopRequireDefault(require("gulp-tap"));

var _gulpZip = _interopRequireDefault(require("gulp-zip"));

var _del = _interopRequireDefault(require("del"));

var _fancyLog = _interopRequireDefault(require("fancy-log"));

var _parseGitignore = _interopRequireDefault(require("parse-gitignore"));

var _core = require("@babel/core");

var _path = require("path");

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _webpack2 = _interopRequireDefault(require("./webpack.config"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

require('dotenv').config();

const {
  WEBPACK_PORT,
  DEV_ENDPOINT,
  HASHING_OUTPUT_LENGTH
} = process.env;
if (typeof WEBPACK_PORT !== 'string') throw new TypeError('WEBPACK_PORT is improperly defined. Did you copy dist.env -> .env ?');
if (typeof DEV_ENDPOINT !== 'string') throw new TypeError('DEV_ENDPOINT is improperly defined. Did you copy dist.env -> .env ?');
if (typeof HASHING_OUTPUT_LENGTH !== 'string') throw new TypeError('HASHING_OUTPUT_LENGTH is improperly defined. Did you copy dist.env -> .env ?');
const DEV_PORT = parseInt(WEBPACK_PORT, 10);
const paths = {};
paths.flowTyped = 'flow-typed';
paths.flowTypedGitIgnore = `${paths.flowTyped}/.gitignore`;
paths.build = `build`;
paths.buildGitIgnore = `${paths.build}/.gitignore`;
paths.configs = 'config';
paths.packageJson = 'package.json';
paths.launchJson = '.vscode/launch.json';
paths.launchJsonDist = '.vscode/launch.dist.json';
paths.env = '.env';
paths.envDist = 'dist.env';
paths.gitProjectDir = '.git';
paths.gitIgnore = '.gitignore';
paths.packageLockJson = 'package-lock.json';
paths.build = `${__dirname}/build`;
paths.regenTargets = [`${paths.configs}/*.js`];
const CLI_BANNER = `/**
* !!! DO NOT EDIT THIS FILE DIRECTLY !!!
* ! This file has been generated automatically. See the config/*.js version of
* ! this file to make permanent modifications!
*/\n\n`;
const readFileAsync = (0, _util.promisify)(_fs.readFile);

const cleanTypes = async () => {
  const targets = (0, _parseGitignore.default)((await readFileAsync(paths.flowTypedGitIgnore)));
  (0, _fancyLog.default)(`Deletion targets @ ${paths.flowTyped}/: "${targets.join('" "')}"`);
  (0, _del.default)(targets, {
    cwd: paths.flowTyped
  });
};

exports.cleanTypes = cleanTypes;
cleanTypes.description = `Resets the ${paths.flowTyped} directory to a pristine state`;

const cleanBuild = async () => {
  const targets = (0, _parseGitignore.default)((await readFileAsync(paths.buildGitIgnore)));
  (0, _fancyLog.default)(`Deletion targets @ ${paths.build}/: "${targets.join('" "')}"`);
  (0, _del.default)(targets, {
    cwd: paths.build
  });
};

exports.cleanBuild = cleanBuild;
cleanTypes.description = `Resets the ${paths.flowTyped} directory to a pristine state`;

const regenerate = () => {
  (0, _fancyLog.default)(`Regenerating targets: "${paths.regenTargets.join('" "')}"`);
  process.env.BABEL_ENV = 'generator';
  return _gulp.default.src(paths.regenTargets).pipe((0, _gulpTap.default)(file => file.contents = Buffer.from(CLI_BANNER + (0, _core.transformSync)(file.contents.toString(), {
    sourceFileName: (0, _path.relative)(__dirname, file.path)
  }).code))).pipe(_gulp.default.dest('.'));
};

exports.regenerate = regenerate;
regenerate.description = 'Invokes babel on the files in config, transpiling them into their project root versions';

const build = () => {
  process.env.NODE_ENV = 'production';
  return new Promise(resolve => {
    (0, _webpack.default)((0, _webpack2.default)({
      NODE_ENV: process.env.NODE_ENV
    }), (err, stats) => {
      if (err) {
        const details = err.details ? `\n\t${err.details}` : '';
        throw `WEBPACK FATAL BUILD ERROR: ${err}${details}`;
      }

      const info = stats.toJson();
      if (stats.hasErrors()) throw `WEBPACK COMPILATION ERROR: ${info.errors}`;
      if (stats.hasWarnings()) console.warn(`WEBPACK COMPILATION WARNING: ${info.warnings}`);
      resolve();
    });
  }).then(() => _gulp.default.src('build/*').pipe((0, _gulpZip.default)(`dnschk-${_package.default.version}.zip`)).pipe(_gulp.default.dest('.')));
};

exports.build = build;
build.description = 'Yields a production-ready extension archive for upload to the Chrome Web Store';

const wpdevserv = () => {
  var _config$plugins;

  Object.keys(_webpack2.default.entry).forEach(entryKey => _webpack2.default.entry[entryKey] = [`webpack-dev-server/client?http://${DEV_ENDPOINT}:${DEV_PORT}`, 'webpack/hot/dev-server', _webpack2.default.entry[entryKey]]);
  _webpack2.default.plugins = [new _webpack.default.HotModuleReplacementPlugin(), ...((_config$plugins = _webpack2.default.plugins) !== null && _config$plugins !== void 0 ? _config$plugins : [])];
  const packer = (0, _webpack.default)(_webpack2.default);
  const server = new _webpackDevServer.default(packer, {
    hot: true,
    contentBase: paths.build,
    headers: {
      'Access-Control-Allow-Origin': '*'
    }
  });
  server.listen(DEV_PORT, err => {
    if (err) throw `WEBPACK DEV SERVER ERROR: ${err}`;
  });
};

exports.wpdevserv = wpdevserv;
wpdevserv.description = 'Launches the Webpack Development Server for testing purposes';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmZpZy9ndWxwZmlsZS5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY29uZmlnIiwiV0VCUEFDS19QT1JUIiwiREVWX0VORFBPSU5UIiwiSEFTSElOR19PVVRQVVRfTEVOR1RIIiwicHJvY2VzcyIsImVudiIsIlR5cGVFcnJvciIsIkRFVl9QT1JUIiwicGFyc2VJbnQiLCJwYXRocyIsImZsb3dUeXBlZCIsImZsb3dUeXBlZEdpdElnbm9yZSIsImJ1aWxkIiwiYnVpbGRHaXRJZ25vcmUiLCJjb25maWdzIiwicGFja2FnZUpzb24iLCJsYXVuY2hKc29uIiwibGF1bmNoSnNvbkRpc3QiLCJlbnZEaXN0IiwiZ2l0UHJvamVjdERpciIsImdpdElnbm9yZSIsInBhY2thZ2VMb2NrSnNvbiIsIl9fZGlybmFtZSIsInJlZ2VuVGFyZ2V0cyIsIkNMSV9CQU5ORVIiLCJyZWFkRmlsZUFzeW5jIiwicmVhZEZpbGUiLCJjbGVhblR5cGVzIiwidGFyZ2V0cyIsImpvaW4iLCJjd2QiLCJkZXNjcmlwdGlvbiIsImNsZWFuQnVpbGQiLCJyZWdlbmVyYXRlIiwiQkFCRUxfRU5WIiwiZ3VscCIsInNyYyIsInBpcGUiLCJmaWxlIiwiY29udGVudHMiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJzb3VyY2VGaWxlTmFtZSIsInBhdGgiLCJjb2RlIiwiZGVzdCIsIk5PREVfRU5WIiwiUHJvbWlzZSIsInJlc29sdmUiLCJlcnIiLCJzdGF0cyIsImRldGFpbHMiLCJpbmZvIiwidG9Kc29uIiwiaGFzRXJyb3JzIiwiZXJyb3JzIiwiaGFzV2FybmluZ3MiLCJjb25zb2xlIiwid2FybiIsIndhcm5pbmdzIiwidGhlbiIsInBrZyIsInZlcnNpb24iLCJ3cGRldnNlcnYiLCJPYmplY3QiLCJrZXlzIiwiZW50cnkiLCJmb3JFYWNoIiwiZW50cnlLZXkiLCJwbHVnaW5zIiwid2VicGFjayIsIkhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIiwicGFja2VyIiwic2VydmVyIiwid2VicGFj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RyxNQUFNLEdBQUcsc0JBQVF6RSxpQkFBUixDQUFmO0FBQ0EsUUFBTTBFLE1BQU0sR0FBRyxJQUFJQyx5QkFBSixDQUFxQkYsTUFBckIsRUFBNkI7QUFDeENHLElBQUFBLEdBQUcsRUFBRSxJQURtQztBQUV4Q0MsSUFBQUEsV0FBVyxFQUFFcEUsS0FBSyxDQUFDRyxLQUZxQjtBQUd4Q2tFLElBQUFBLE9BQU8sRUFBRTtBQUFFLHFDQUErQjtBQUFqQztBQUgrQixHQUE3QixDQUFmO0FBTUFKLEVBQUFBLE1BQU0sQ0FBQ0ssTUFBUCxDQUFjeEUsUUFBZCxFQUF3QjJDLEdBQUcsSUFBSTtBQUFFLFFBQUdBLEdBQUgsRUFBUSxNQUFPLDZCQUE0QkEsR0FBSSxFQUF2QztBQUEwQyxHQUFuRjtBQUNILENBcEJEOzs7QUFzQkFjLFNBQVMsQ0FBQ2pDLFdBQVYsR0FBd0IsOERBQXhCIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuLy8gPyBUbyByZWdlbmVyYXRlIHRoaXMgZmlsZSAoaS5lLiBpZiB5b3UgY2hhbmdlZCBpdCBhbmQgd2FudCB5b3VyIGNoYW5nZXMgdG9cbi8vID8gYmUgcGVybWFuZW50KSwgY2FsbCBgbnBtIHJ1biByZWdlbmVyYXRlYCBhZnRlcndhcmRzXG5cbi8vICEgQmUgc3VyZSB0aGF0IHRhc2tzIGV4cGVjdGVkIHRvIHJ1biBvbiBucG0gaW5zdGFsbCAobWFya2VkIEBkZXBlbmRlbnQpIGhhdmVcbi8vICEgYWxsIHJlcXVpcmVkIHBhY2thZ2VzIGxpc3RlZCB1bmRlciBcImRlcGVuZGVuY2llc1wiIGluc3RlYWQgb2Zcbi8vICEgXCJkZXZEZXBlbmRlbmNpZXNcIiBpbiB0aGlzIHByb2plY3QncyBwYWNrYWdlLmpzb25cblxuLy8gVE9ETzogb24gYWxsIGJ1aWxkIHJ1biBjb21tYW5kcywgYnVtcCB0aGUgYnVpbGQgcGFja2FnZSB2ZXJzaW9uXG4vLyBUT0RPOiBhZGQgXCJ2ZXJzaW9uIGJ1bXBcIiBjb21tYW5kcyBmb3IgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIGJ1aWxkIHZlcnNpb25zXG5cbmltcG9ydCB7IHJlYWRGaWxlIH0gZnJvbSAnZnMnXG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJ1xuaW1wb3J0IGd1bHAgZnJvbSAnZ3VscCdcbmltcG9ydCB0YXAgZnJvbSAnZ3VscC10YXAnXG5pbXBvcnQgemlwIGZyb20gJ2d1bHAtemlwJ1xuaW1wb3J0IGRlbCBmcm9tICdkZWwnXG5pbXBvcnQgbG9nIGZyb20gJ2ZhbmN5LWxvZydcbmltcG9ydCBwYXJzZUdpdElnbm9yZSBmcm9tICdwYXJzZS1naXRpZ25vcmUnXG5pbXBvcnQgeyB0cmFuc2Zvcm1TeW5jIGFzIGJhYmVsIH0gZnJvbSAnQGJhYmVsL2NvcmUnXG5pbXBvcnQgeyByZWxhdGl2ZSBhcyByZWxQYXRoIH0gZnJvbSAncGF0aCdcbmltcG9ydCB3ZWJwYWNrIGZyb20gJ3dlYnBhY2snXG5pbXBvcnQgd2VicGFja0RldlNlcnZlciBmcm9tICd3ZWJwYWNrLWRldi1zZXJ2ZXInXG5pbXBvcnQgY29uZmlnIGZyb20gJy4vd2VicGFjay5jb25maWcnXG5pbXBvcnQgcGtnIGZyb20gJy4vcGFja2FnZSdcblxucmVxdWlyZSgnZG90ZW52JykuY29uZmlnKCk7XG5cbmNvbnN0IHtcbiAgICBXRUJQQUNLX1BPUlQsXG4gICAgREVWX0VORFBPSU5ULFxuICAgIEhBU0hJTkdfT1VUUFVUX0xFTkdUSFxufSA9IHByb2Nlc3MuZW52O1xuXG5pZih0eXBlb2YgV0VCUEFDS19QT1JUICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXRUJQQUNLX1BPUlQgaXMgaW1wcm9wZXJseSBkZWZpbmVkLiBEaWQgeW91IGNvcHkgZGlzdC5lbnYgLT4gLmVudiA/Jyk7XG5cbmlmKHR5cGVvZiBERVZfRU5EUE9JTlQgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RFVl9FTkRQT0lOVCBpcyBpbXByb3Blcmx5IGRlZmluZWQuIERpZCB5b3UgY29weSBkaXN0LmVudiAtPiAuZW52ID8nKTtcblxuaWYodHlwZW9mIEhBU0hJTkdfT1VUUFVUX0xFTkdUSCAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSEFTSElOR19PVVRQVVRfTEVOR1RIIGlzIGltcHJvcGVybHkgZGVmaW5lZC4gRGlkIHlvdSBjb3B5IGRpc3QuZW52IC0+IC5lbnYgPycpO1xuXG5jb25zdCBERVZfUE9SVCA9IHBhcnNlSW50KFdFQlBBQ0tfUE9SVCwgMTApO1xuXG5jb25zdCBwYXRocyA9IHt9O1xuXG5wYXRocy5mbG93VHlwZWQgPSAnZmxvdy10eXBlZCc7XG5wYXRocy5mbG93VHlwZWRHaXRJZ25vcmUgPSBgJHtwYXRocy5mbG93VHlwZWR9Ly5naXRpZ25vcmVgO1xucGF0aHMuYnVpbGQgPSBgYnVpbGRgO1xucGF0aHMuYnVpbGRHaXRJZ25vcmUgPSBgJHtwYXRocy5idWlsZH0vLmdpdGlnbm9yZWA7XG5wYXRocy5jb25maWdzID0gJ2NvbmZpZyc7XG5wYXRocy5wYWNrYWdlSnNvbiA9ICdwYWNrYWdlLmpzb24nO1xucGF0aHMubGF1bmNoSnNvbiA9ICcudnNjb2RlL2xhdW5jaC5qc29uJztcbnBhdGhzLmxhdW5jaEpzb25EaXN0ID0gJy52c2NvZGUvbGF1bmNoLmRpc3QuanNvbic7XG5wYXRocy5lbnYgPSAnLmVudic7XG5wYXRocy5lbnZEaXN0ID0gJ2Rpc3QuZW52JztcbnBhdGhzLmdpdFByb2plY3REaXIgPSAnLmdpdCc7XG5wYXRocy5naXRJZ25vcmUgPSAnLmdpdGlnbm9yZSc7XG5wYXRocy5wYWNrYWdlTG9ja0pzb24gPSAncGFja2FnZS1sb2NrLmpzb24nO1xucGF0aHMuYnVpbGQgPSBgJHtfX2Rpcm5hbWV9L2J1aWxkYDtcblxucGF0aHMucmVnZW5UYXJnZXRzID0gW1xuICAgIGAke3BhdGhzLmNvbmZpZ3N9LyouanNgXG5dO1xuXG5jb25zdCBDTElfQkFOTkVSID0gYC8qKlxuKiAhISEgRE8gTk9UIEVESVQgVEhJUyBGSUxFIERJUkVDVExZICEhIVxuKiAhIFRoaXMgZmlsZSBoYXMgYmVlbiBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS4gU2VlIHRoZSBjb25maWcvKi5qcyB2ZXJzaW9uIG9mXG4qICEgdGhpcyBmaWxlIHRvIG1ha2UgcGVybWFuZW50IG1vZGlmaWNhdGlvbnMhXG4qL1xcblxcbmA7XG5cbmNvbnN0IHJlYWRGaWxlQXN5bmMgPSBwcm9taXNpZnkocmVhZEZpbGUpO1xuXG4vLyAqIENMRUFOVFlQRVNcblxuY29uc3QgY2xlYW5UeXBlcyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB0YXJnZXRzID0gcGFyc2VHaXRJZ25vcmUoYXdhaXQgcmVhZEZpbGVBc3luYyhwYXRocy5mbG93VHlwZWRHaXRJZ25vcmUpKTtcblxuICAgIGxvZyhgRGVsZXRpb24gdGFyZ2V0cyBAICR7cGF0aHMuZmxvd1R5cGVkfS86IFwiJHt0YXJnZXRzLmpvaW4oJ1wiIFwiJyl9XCJgKTtcbiAgICBkZWwodGFyZ2V0cywge2N3ZDogcGF0aHMuZmxvd1R5cGVkfSk7XG59O1xuXG5jbGVhblR5cGVzLmRlc2NyaXB0aW9uID0gYFJlc2V0cyB0aGUgJHtwYXRocy5mbG93VHlwZWR9IGRpcmVjdG9yeSB0byBhIHByaXN0aW5lIHN0YXRlYDtcblxuLy8gKiBDTEVBTkJVSUxEXG5cbmNvbnN0IGNsZWFuQnVpbGQgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0cyA9IHBhcnNlR2l0SWdub3JlKGF3YWl0IHJlYWRGaWxlQXN5bmMocGF0aHMuYnVpbGRHaXRJZ25vcmUpKTtcblxuICAgIGxvZyhgRGVsZXRpb24gdGFyZ2V0cyBAICR7cGF0aHMuYnVpbGR9LzogXCIke3RhcmdldHMuam9pbignXCIgXCInKX1cImApO1xuICAgIGRlbCh0YXJnZXRzLCB7Y3dkOiBwYXRocy5idWlsZH0pO1xufTtcblxuY2xlYW5UeXBlcy5kZXNjcmlwdGlvbiA9IGBSZXNldHMgdGhlICR7cGF0aHMuZmxvd1R5cGVkfSBkaXJlY3RvcnkgdG8gYSBwcmlzdGluZSBzdGF0ZWA7XG5cbi8vICogUkVHRU5FUkFURVxuXG4vLyA/IElmIHlvdSBjaGFuZ2UgdGhpcyBmdW5jdGlvbiwgcnVuIGBucG0gcnVuIHJlZ2VuZXJhdGVgIHR3aWNlOiBvbmNlIHRvXG4vLyA/IGNvbXBpbGUgdGhpcyBuZXcgZnVuY3Rpb24gYW5kIG9uY2UgYWdhaW4gdG8gY29tcGlsZSBpdHNlbGYgd2l0aCB0aGUgbmV3bHlcbi8vID8gY29tcGlsZWQgbG9naWMuIElmIHRoZXJlIGlzIGFuIGVycm9yIHRoYXQgcHJldmVudHMgcmVnZW5lcmF0aW9uLCB5b3UgY2FuXG4vLyA/IHJ1biBgbnBtIHJ1biBnZW5lcmF0ZWAgdGhlbiBgbnBtIHJ1biByZWdlbmVyYXRlYCBpbnN0ZWFkLlxuY29uc3QgcmVnZW5lcmF0ZSA9ICgpID0+IHtcbiAgICBsb2coYFJlZ2VuZXJhdGluZyB0YXJnZXRzOiBcIiR7cGF0aHMucmVnZW5UYXJnZXRzLmpvaW4oJ1wiIFwiJyl9XCJgKTtcblxuICAgIHByb2Nlc3MuZW52LkJBQkVMX0VOViA9ICdnZW5lcmF0b3InO1xuXG4gICAgcmV0dXJuIGd1bHAuc3JjKHBhdGhzLnJlZ2VuVGFyZ2V0cylcbiAgICAgICAgLnBpcGUodGFwKGZpbGUgPT4gZmlsZS5jb250ZW50cyA9IEJ1ZmZlci5mcm9tKENMSV9CQU5ORVIgKyBiYWJlbChmaWxlLmNvbnRlbnRzLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGVOYW1lOiByZWxQYXRoKF9fZGlybmFtZSwgZmlsZS5wYXRoKVxuICAgICAgICB9KS5jb2RlKSkpXG4gICAgICAgIC5waXBlKGd1bHAuZGVzdCgnLicpKTtcbn07XG5cbnJlZ2VuZXJhdGUuZGVzY3JpcHRpb24gPSAnSW52b2tlcyBiYWJlbCBvbiB0aGUgZmlsZXMgaW4gY29uZmlnLCB0cmFuc3BpbGluZyB0aGVtIGludG8gdGhlaXIgcHJvamVjdCByb290IHZlcnNpb25zJztcblxuLy8gKiBCVUlMRCAocHJvZHVjdGlvbilcblxuY29uc3QgYnVpbGQgPSAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB3ZWJwYWNrKGNvbmZpZyh7IE5PREVfRU5WOiBwcm9jZXNzLmVudi5OT0RFX0VOViB9KSwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICAgIGlmKGVycilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gZXJyLmRldGFpbHMgPyBgXFxuXFx0JHtlcnIuZGV0YWlsc31gIDogJyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFdFQlBBQ0sgRkFUQUwgQlVJTEQgRVJST1I6ICR7ZXJyfSR7ZGV0YWlsc31gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmZvID0gc3RhdHMudG9Kc29uKCk7XG5cbiAgICAgICAgICAgIGlmKHN0YXRzLmhhc0Vycm9ycygpKVxuICAgICAgICAgICAgICAgIHRocm93IGBXRUJQQUNLIENPTVBJTEFUSU9OIEVSUk9SOiAke2luZm8uZXJyb3JzfWA7XG5cbiAgICAgICAgICAgIGlmKHN0YXRzLmhhc1dhcm5pbmdzKCkpXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXRUJQQUNLIENPTVBJTEFUSU9OIFdBUk5JTkc6ICR7aW5mby53YXJuaW5nc31gKTtcblxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAvLyA/IEFmdGVyd2FyZHMsIHppcCB0aGUgYnVpbGQgZGlyZWN0b3J5IHVwXG4gICAgfSkudGhlbigoKSA9PiBndWxwLnNyYygnYnVpbGQvKicpLnBpcGUoemlwKGBkbnNjaGstJHtwa2cudmVyc2lvbn0uemlwYCkpLnBpcGUoZ3VscC5kZXN0KCcuJykpKTtcbn07XG5cbmJ1aWxkLmRlc2NyaXB0aW9uID0gJ1lpZWxkcyBhIHByb2R1Y3Rpb24tcmVhZHkgZXh0ZW5zaW9uIGFyY2hpdmUgZm9yIHVwbG9hZCB0byB0aGUgQ2hyb21lIFdlYiBTdG9yZSc7XG5cbi8vICogV1BERVZTRVJWXG5cbmNvbnN0IHdwZGV2c2VydiA9ICgpID0+IHtcbiAgICBPYmplY3Qua2V5cyhjb25maWcuZW50cnkpLmZvckVhY2goZW50cnlLZXkgPT4gY29uZmlnLmVudHJ5W2VudHJ5S2V5XSA9IFtcbiAgICAgICAgYHdlYnBhY2stZGV2LXNlcnZlci9jbGllbnQ/aHR0cDovLyR7REVWX0VORFBPSU5UfToke0RFVl9QT1JUfWAsXG4gICAgICAgICd3ZWJwYWNrL2hvdC9kZXYtc2VydmVyJyxcbiAgICAgICAgY29uZmlnLmVudHJ5W2VudHJ5S2V5XVxuICAgIF0pO1xuXG4gICAgY29uZmlnLnBsdWdpbnMgPSBbXG4gICAgICAgIG5ldyB3ZWJwYWNrLkhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luKCksXG4gICAgICAgIC4uLihjb25maWcucGx1Z2lucyA/PyBbXSksXG4gICAgXTtcblxuICAgIGNvbnN0IHBhY2tlciA9IHdlYnBhY2soY29uZmlnKTtcbiAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgd2VicGFja0RldlNlcnZlcihwYWNrZXIsIHtcbiAgICAgICAgaG90OiB0cnVlLFxuICAgICAgICBjb250ZW50QmFzZTogcGF0aHMuYnVpbGQsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJyB9XG4gICAgfSk7XG5cbiAgICBzZXJ2ZXIubGlzdGVuKERFVl9QT1JULCBlcnIgPT4geyBpZihlcnIpIHRocm93IGBXRUJQQUNLIERFViBTRVJWRVIgRVJST1I6ICR7ZXJyfWAgfSk7XG59O1xuXG53cGRldnNlcnYuZGVzY3JpcHRpb24gPSAnTGF1bmNoZXMgdGhlIFdlYnBhY2sgRGV2ZWxvcG1lbnQgU2VydmVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzJztcblxuZXhwb3J0IHsgcmVnZW5lcmF0ZSwgY2xlYW5UeXBlcywgY2xlYW5CdWlsZCwgd3BkZXZzZXJ2LCBidWlsZCB9O1xuIl19