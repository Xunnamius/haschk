/**
* !!! DO NOT EDIT THIS FILE DIRECTLY !!!
* ! This file has been generated automatically. See the config/*.js version of
* ! this file to make permanent modifications!
*/

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wpdevserv = exports.bundleZip = exports.build = exports.regenerate = exports.cleanBuild = exports.cleanTypes = void 0;

require("source-map-support/register");

var _fs = require("fs");

var _util = require("util");

var _gulp = _interopRequireDefault(require("gulp"));

var _gulpTap = _interopRequireDefault(require("gulp-tap"));

var _gulpZip = _interopRequireDefault(require("gulp-zip"));

var _del = _interopRequireDefault(require("del"));

var _fancyLog = _interopRequireDefault(require("fancy-log"));

var _parseGitignore = _interopRequireDefault(require("parse-gitignore"));

var _core = require("@babel/core");

var _path = require("path");

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _webpack2 = _interopRequireDefault(require("./webpack.config"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

require('dotenv').config();

process.env.NODE_ENV = process.env.NODE_ENV || 'development';
const {
  WEBPACK_PORT,
  DEV_ENDPOINT,
  HASHING_ALGORITHM
} = process.env;
if (typeof WEBPACK_PORT !== 'string') throw new TypeError('WEBPACK_PORT is improperly defined. Did you copy dist.env -> .env ?');
if (typeof DEV_ENDPOINT !== 'string') throw new TypeError('DEV_ENDPOINT is improperly defined. Did you copy dist.env -> .env ?');
if (typeof HASHING_ALGORITHM !== 'string') throw new TypeError('HASHING_ALGORITHM is improperly defined. Did you copy dist.env -> .env ?');
const DEV_PORT = parseInt(WEBPACK_PORT, 10);
const paths = {};
paths.flowTyped = 'flow-typed';
paths.flowTypedGitIgnore = `${paths.flowTyped}/.gitignore`;
paths.build = `build`;
paths.configs = 'config';
paths.packageJson = 'package.json';
paths.launchJson = '.vscode/launch.json';
paths.launchJsonDist = '.vscode/launch.dist.json';
paths.env = '.env';
paths.envDist = 'dist.env';
paths.gitProjectDir = '.git';
paths.gitIgnore = '.gitignore';
paths.packageLockJson = 'package-lock.json';
paths.regenTargets = [`${paths.configs}/*.js`];
const CLI_BANNER = `/**
* !!! DO NOT EDIT THIS FILE DIRECTLY !!!
* ! This file has been generated automatically. See the config/*.js version of
* ! this file to make permanent modifications!
*/\n\n`;
const readFileAsync = (0, _util.promisify)(_fs.readFile);

const generateWebpackConfig = () => (0, _webpack2.default)({
  NODE_ENV: process.env.NODE_ENV
});

const cleanTypes = async () => {
  const targets = (0, _parseGitignore.default)((await readFileAsync(paths.flowTypedGitIgnore)));
  (0, _fancyLog.default)(`Deletion targets @ ${paths.flowTyped}/: "${targets.join('" "')}"`);
  await (0, _del.default)(targets, {
    cwd: paths.flowTyped
  });
};

exports.cleanTypes = cleanTypes;
cleanTypes.description = `Resets the ${paths.flowTyped} directory to a pristine state`;

const cleanBuild = async () => {
  (0, _fancyLog.default)(`Deletion targets @ ${paths.build}/*`);
  await (0, _del.default)('*', {
    cwd: paths.build
  });
};

exports.cleanBuild = cleanBuild;
cleanBuild.description = `Resets the ${paths.build} directory to a pristine state`;

const regenerate = () => {
  (0, _fancyLog.default)(`Regenerating targets: "${paths.regenTargets.join('" "')}"`);
  process.env.BABEL_ENV = 'generator';
  return _gulp.default.src(paths.regenTargets).pipe((0, _gulpTap.default)(file => file.contents = Buffer.from(CLI_BANNER + (0, _core.transformSync)(file.contents.toString(), {
    sourceFileName: (0, _path.relative)(__dirname, file.path)
  }).code))).pipe(_gulp.default.dest('.'));
};

exports.regenerate = regenerate;
regenerate.description = 'Invokes babel on the files in config, transpiling them into their project root versions';

const build = () => {
  process.env.NODE_ENV = 'production';
  const configured = generateWebpackConfig();
  return new Promise(resolve => {
    (0, _webpack.default)(configured, (err, stats) => {
      if (err) {
        const details = err.details ? `\n\t${err.details}` : '';
        throw `WEBPACK FATAL BUILD ERROR: ${err.toString()}${details}`;
      }

      const info = stats.toJson();
      if (stats.hasErrors()) throw `WEBPACK COMPILATION ERROR: ${info.errors}`;
      if (stats.hasWarnings()) console.warn(`WEBPACK COMPILATION WARNING: ${info.warnings}`);
      resolve();
    });
  });
};

exports.build = build;
build.description = 'Yields a production-ready unpacked extension via the build directory';

const bundleZip = async () => {
  await (0, _del.default)([`${_package.default.name}-*.zip`]).then(() => {
    _gulp.default.src('build/**/*').pipe((0, _gulpZip.default)(`${_package.default.name}-${_package.default.version}.zip`)).pipe(_gulp.default.dest('.'));
  });
};

exports.bundleZip = bundleZip;
bundleZip.description = 'Bundles the build directory into a zip archive for upload to the Chrome Web Store and elsewhere';

const wpdevserv = () => {
  var _configured$plugins;

  const configured = generateWebpackConfig();
  Object.keys(configured.entry).forEach(entryKey => configured.entry[entryKey] = [`webpack-dev-server/client?http://${DEV_ENDPOINT}:${DEV_PORT}`, 'webpack/hot/dev-server'].concat(configured.entry[entryKey]));
  configured.plugins = [new _webpack.default.HotModuleReplacementPlugin(), ...((_configured$plugins = configured.plugins) !== null && _configured$plugins !== void 0 ? _configured$plugins : [])];
  const packer = (0, _webpack.default)(configured);
  const server = new _webpackDevServer.default(packer, {
    disableHostCheck: true,
    hot: true,
    contentBase: (0, _path.join)(__dirname, paths.build),
    headers: {
      'Access-Control-Allow-Origin': '*'
    },
    publicPath: `http://${DEV_ENDPOINT}:${DEV_PORT}/`,
    sockHost: DEV_ENDPOINT,
    sockPort: DEV_PORT
  });
  server.listen(DEV_PORT, '0.0.0.0', err => {
    if (err) throw `WEBPACK DEV SERVER ERROR: ${err}`;
  });
};

exports.wpdevserv = wpdevserv;
wpdevserv.description = 'Launches the Webpack Development Server for testing purposes';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmZpZy9ndWxwZmlsZS5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY29uZmlnIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiV0VCUEFDS19QT1JUIiwiREVWX0VORFBPSU5UIiwiSEFTSElOR19BTEdPUklUSE0iLCJUeXBlRXJyb3IiLCJERVZfUE9SVCIsInBhcnNlSW50IiwicGF0aHMiLCJmbG93VHlwZWQiLCJmbG93VHlwZWRHaXRJZ25vcmUiLCJidWlsZCIsImNvbmZpZ3MiLCJwYWNrYWdlSnNvbiIsImxhdW5jaEpzb24iLCJsYXVuY2hKc29uRGlzdCIsImVudkRpc3QiLCJnaXRQcm9qZWN0RGlyIiwiZ2l0SWdub3JlIiwicGFja2FnZUxvY2tKc29uIiwicmVnZW5UYXJnZXRzIiwiQ0xJX0JBTk5FUiIsInJlYWRGaWxlQXN5bmMiLCJyZWFkRmlsZSIsImdlbmVyYXRlV2VicGFja0NvbmZpZyIsImNsZWFuVHlwZXMiLCJ0YXJnZXRzIiwiam9pbiIsImN3ZCIsImRlc2NyaXB0aW9uIiwiY2xlYW5CdWlsZCIsInJlZ2VuZXJhdGUiLCJCQUJFTF9FTlYiLCJndWxwIiwic3JjIiwicGlwZSIsImZpbGUiLCJjb250ZW50cyIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsInNvdXJjZUZpbGVOYW1lIiwiX19kaXJuYW1lIiwicGF0aCIsImNvZGUiLCJkZXN0IiwiY29uZmlndXJlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyIiwic3RhdHMiLCJkZXRhaWxzIiwiaW5mbyIsInRvSnNvbiIsImhhc0Vycm9ycyIsImVycm9ycyIsImhhc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJ3YXJuaW5ncyIsImJ1bmRsZVppcCIsInBrZyIsIm5hbWUiLCJ0aGVuIiwidmVyc2lvbiIsIndwZGV2c2VydiIsIk9iamVjdCIsImtleXMiLCJlbnRyeSIsImZvckVhY2giLCJlbnRyeUtleSIsImNvbmNhdCIsInBsdWdpbnMiLCJ3ZWJwYWNrIiwiSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4iLCJwYWNrZXIiLCJzZXJ2ZXIiLCJXZWJwYWNrRGV2U2VydmVyIiwiZGlzYWJsZUhvc3RDaGVjayIsImhvdCIsImNvbnRlbnRCYXNlIiwiaGVhZGVycyIsInB1YmxpY1BhdGgiLCJzb2NrSG9zdCIsInNvY2tQb3J0IiwibGlzdGVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFRQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVBQSxPQUFPLENBQUMsUUFBRCxDQUFQLENBQWtCQyxNQUFsQjs7QUFFQUMsT0FBTyxDQUFDQyxHQUFSLENBQVlDLFFBQVosR0FBdUJGLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxRQUFaLElBQXdCLGFBQS9DO0FBRUEsTUFBTTtBQUNGQyxFQUFBQSxZQURFO0FBRUZDLEVBQUFBLFlBRkU7QUFHRkMsRUFBQUE7QUFIRSxJQUlGTCxPQUFPLENBQUNDLEdBSlo7QUFNQSxJQUFHLE9BQU9FLFlBQVAsS0FBd0IsUUFBM0IsRUFDSSxNQUFNLElBQUlHLFNBQUosQ0FBYyxxRUFBZCxDQUFOO0FBRUosSUFBRyxPQUFPRixZQUFQLEtBQXdCLFFBQTNCLEVBQ0ksTUFBTSxJQUFJRSxTQUFKLENBQWMscUVBQWQsQ0FBTjtBQUVKLElBQUcsT0FBT0QsaUJBQVAsS0FBNkIsUUFBaEMsRUFDSSxNQUFNLElBQUlDLFNBQUosQ0FBYywwRUFBZCxDQUFOO0FBRUosTUFBTUMsUUFBUSxHQUFHQyxRQUFRLENBQUNMLFlBQUQsRUFBZSxFQUFmLENBQXpCO0FBRUEsTUFBTU0sS0FBSyxHQUFHLEVBQWQ7QUFFQUEsS0FBSyxDQUFDQyxTQUFOLEdBQWtCLFlBQWxCO0FBQ0FELEtBQUssQ0FBQ0Usa0JBQU4sR0FBNEIsR0FBRUYsS0FBSyxDQUFDQyxTQUFVLGFBQTlDO0FBQ0FELEtBQUssQ0FBQ0csS0FBTixHQUFlLE9BQWY7QUFDQUgsS0FBSyxDQUFDSSxPQUFOLEdBQWdC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OlsiLyogQGZsb3cgKi9cblxuLy8gPyBUbyByZWdlbmVyYXRlIHRoaXMgZmlsZSAoaS5lLiBpZiB5b3UgY2hhbmdlZCBpdCBhbmQgd2FudCB5b3VyIGNoYW5nZXMgdG9cbi8vID8gYmUgdmlzaWJsZSksIGNhbGwgYG5wbSBydW4gcmVnZW5lcmF0ZWAgYWZ0ZXJ3YXJkc1xuXG4vLyBUT0RPOiBtYWtlIGEgZm9yayBvZiBucG0tYnVtcCB0aGF0IGRvZXNuJ3Qgc3VjayBhbmQgdGhlbiB1c2UgaXQgaW4gbGlldSBvZlxuLy8gVE9ETzogaXRzIHByZWRlY2Vzc29yIGJlbG93LlxuXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gJ2ZzJ1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCdcbmltcG9ydCBndWxwIGZyb20gJ2d1bHAnXG5pbXBvcnQgdGFwIGZyb20gJ2d1bHAtdGFwJ1xuaW1wb3J0IHppcCBmcm9tICdndWxwLXppcCdcbmltcG9ydCBkZWwgZnJvbSAnZGVsJ1xuaW1wb3J0IGxvZyBmcm9tICdmYW5jeS1sb2cnXG5pbXBvcnQgcGFyc2VHaXRJZ25vcmUgZnJvbSAncGFyc2UtZ2l0aWdub3JlJ1xuaW1wb3J0IHsgdHJhbnNmb3JtU3luYyBhcyBiYWJlbCB9IGZyb20gJ0BiYWJlbC9jb3JlJ1xuaW1wb3J0IHsgcmVsYXRpdmUgYXMgcmVsUGF0aCwgam9pbiBhcyBqb2luUGF0aCB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgd2VicGFjayBmcm9tICd3ZWJwYWNrJ1xuaW1wb3J0IFdlYnBhY2tEZXZTZXJ2ZXIgZnJvbSAnd2VicGFjay1kZXYtc2VydmVyJ1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuL3dlYnBhY2suY29uZmlnJ1xuLy8gZmxvdy1kaXNhYmxlLWxpbmVcbmltcG9ydCBwa2cgZnJvbSAnLi9wYWNrYWdlJ1xuXG5yZXF1aXJlKCdkb3RlbnYnKS5jb25maWcoKTtcblxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuXG5jb25zdCB7XG4gICAgV0VCUEFDS19QT1JULFxuICAgIERFVl9FTkRQT0lOVCxcbiAgICBIQVNISU5HX0FMR09SSVRITVxufSA9IHByb2Nlc3MuZW52O1xuXG5pZih0eXBlb2YgV0VCUEFDS19QT1JUICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXRUJQQUNLX1BPUlQgaXMgaW1wcm9wZXJseSBkZWZpbmVkLiBEaWQgeW91IGNvcHkgZGlzdC5lbnYgLT4gLmVudiA/Jyk7XG5cbmlmKHR5cGVvZiBERVZfRU5EUE9JTlQgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RFVl9FTkRQT0lOVCBpcyBpbXByb3Blcmx5IGRlZmluZWQuIERpZCB5b3UgY29weSBkaXN0LmVudiAtPiAuZW52ID8nKTtcblxuaWYodHlwZW9mIEhBU0hJTkdfQUxHT1JJVEhNICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIQVNISU5HX0FMR09SSVRITSBpcyBpbXByb3Blcmx5IGRlZmluZWQuIERpZCB5b3UgY29weSBkaXN0LmVudiAtPiAuZW52ID8nKTtcblxuY29uc3QgREVWX1BPUlQgPSBwYXJzZUludChXRUJQQUNLX1BPUlQsIDEwKTtcblxuY29uc3QgcGF0aHMgPSB7fTtcblxucGF0aHMuZmxvd1R5cGVkID0gJ2Zsb3ctdHlwZWQnO1xucGF0aHMuZmxvd1R5cGVkR2l0SWdub3JlID0gYCR7cGF0aHMuZmxvd1R5cGVkfS8uZ2l0aWdub3JlYDtcbnBhdGhzLmJ1aWxkID0gYGJ1aWxkYDtcbnBhdGhzLmNvbmZpZ3MgPSAnY29uZmlnJztcbnBhdGhzLnBhY2thZ2VKc29uID0gJ3BhY2thZ2UuanNvbic7XG5wYXRocy5sYXVuY2hKc29uID0gJy52c2NvZGUvbGF1bmNoLmpzb24nO1xucGF0aHMubGF1bmNoSnNvbkRpc3QgPSAnLnZzY29kZS9sYXVuY2guZGlzdC5qc29uJztcbnBhdGhzLmVudiA9ICcuZW52JztcbnBhdGhzLmVudkRpc3QgPSAnZGlzdC5lbnYnO1xucGF0aHMuZ2l0UHJvamVjdERpciA9ICcuZ2l0JztcbnBhdGhzLmdpdElnbm9yZSA9ICcuZ2l0aWdub3JlJztcbnBhdGhzLnBhY2thZ2VMb2NrSnNvbiA9ICdwYWNrYWdlLWxvY2suanNvbic7XG5cbnBhdGhzLnJlZ2VuVGFyZ2V0cyA9IFtcbiAgICBgJHtwYXRocy5jb25maWdzfS8qLmpzYFxuXTtcblxuY29uc3QgQ0xJX0JBTk5FUiA9IGAvKipcbiogISEhIERPIE5PVCBFRElUIFRISVMgRklMRSBESVJFQ1RMWSAhISFcbiogISBUaGlzIGZpbGUgaGFzIGJlZW4gZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuIFNlZSB0aGUgY29uZmlnLyouanMgdmVyc2lvbiBvZlxuKiAhIHRoaXMgZmlsZSB0byBtYWtlIHBlcm1hbmVudCBtb2RpZmljYXRpb25zIVxuKi9cXG5cXG5gO1xuXG5jb25zdCByZWFkRmlsZUFzeW5jID0gcHJvbWlzaWZ5KHJlYWRGaWxlKTtcbmNvbnN0IGdlbmVyYXRlV2VicGFja0NvbmZpZyA9ICgpID0+IGNvbmZpZyh7IE5PREVfRU5WOiBwcm9jZXNzLmVudi5OT0RFX0VOViB9KTtcblxuLy8gKiBDTEVBTlRZUEVTXG5cbmV4cG9ydCBjb25zdCBjbGVhblR5cGVzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldHMgPSBwYXJzZUdpdElnbm9yZShhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGhzLmZsb3dUeXBlZEdpdElnbm9yZSkpO1xuXG4gICAgbG9nKGBEZWxldGlvbiB0YXJnZXRzIEAgJHtwYXRocy5mbG93VHlwZWR9LzogXCIke3RhcmdldHMuam9pbignXCIgXCInKX1cImApO1xuICAgIGF3YWl0IGRlbCh0YXJnZXRzLCB7IGN3ZDogcGF0aHMuZmxvd1R5cGVkIH0pO1xufTtcblxuY2xlYW5UeXBlcy5kZXNjcmlwdGlvbiA9IGBSZXNldHMgdGhlICR7cGF0aHMuZmxvd1R5cGVkfSBkaXJlY3RvcnkgdG8gYSBwcmlzdGluZSBzdGF0ZWA7XG5cbi8vICogQ0xFQU5CVUlMRFxuXG5leHBvcnQgY29uc3QgY2xlYW5CdWlsZCA9IGFzeW5jICgpID0+IHtcbiAgICBsb2coYERlbGV0aW9uIHRhcmdldHMgQCAke3BhdGhzLmJ1aWxkfS8qYCk7XG4gICAgYXdhaXQgZGVsKCcqJywgeyBjd2Q6IHBhdGhzLmJ1aWxkIH0pO1xufTtcblxuY2xlYW5CdWlsZC5kZXNjcmlwdGlvbiA9IGBSZXNldHMgdGhlICR7cGF0aHMuYnVpbGR9IGRpcmVjdG9yeSB0byBhIHByaXN0aW5lIHN0YXRlYDtcblxuLy8gKiBSRUdFTkVSQVRFXG5cbi8vID8gSWYgeW91IGNoYW5nZSB0aGlzIGZ1bmN0aW9uLCBydW4gYG5wbSBydW4gcmVnZW5lcmF0ZWAgdHdpY2U6IG9uY2UgdG9cbi8vID8gY29tcGlsZSB0aGlzIG5ldyBmdW5jdGlvbiBhbmQgb25jZSBhZ2FpbiB0byBjb21waWxlIGl0c2VsZiB3aXRoIHRoZSBuZXdseVxuLy8gPyBjb21waWxlZCBsb2dpYy4gSWYgdGhlcmUgaXMgYW4gZXJyb3IgdGhhdCBwcmV2ZW50cyByZWdlbmVyYXRpb24sIHlvdSBjYW5cbi8vID8gcnVuIGBucG0gcnVuIGdlbmVyYXRlYCB0aGVuIGBucG0gcnVuIHJlZ2VuZXJhdGVgIGluc3RlYWQuXG5leHBvcnQgY29uc3QgcmVnZW5lcmF0ZSA9ICgpID0+IHtcbiAgICBsb2coYFJlZ2VuZXJhdGluZyB0YXJnZXRzOiBcIiR7cGF0aHMucmVnZW5UYXJnZXRzLmpvaW4oJ1wiIFwiJyl9XCJgKTtcblxuICAgIHByb2Nlc3MuZW52LkJBQkVMX0VOViA9ICdnZW5lcmF0b3InO1xuXG4gICAgcmV0dXJuIGd1bHAuc3JjKHBhdGhzLnJlZ2VuVGFyZ2V0cylcbiAgICAgICAgLnBpcGUodGFwKGZpbGUgPT4gZmlsZS5jb250ZW50cyA9IEJ1ZmZlci5mcm9tKENMSV9CQU5ORVIgKyBiYWJlbChmaWxlLmNvbnRlbnRzLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGVOYW1lOiByZWxQYXRoKF9fZGlybmFtZSwgZmlsZS5wYXRoKVxuICAgICAgICB9KS5jb2RlKSkpXG4gICAgICAgIC5waXBlKGd1bHAuZGVzdCgnLicpKTtcbn07XG5cbnJlZ2VuZXJhdGUuZGVzY3JpcHRpb24gPSAnSW52b2tlcyBiYWJlbCBvbiB0aGUgZmlsZXMgaW4gY29uZmlnLCB0cmFuc3BpbGluZyB0aGVtIGludG8gdGhlaXIgcHJvamVjdCByb290IHZlcnNpb25zJztcblxuLy8gKiBCVUlMRCAocHJvZHVjdGlvbilcblxuZXhwb3J0IGNvbnN0IGJ1aWxkID0gKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID0gJ3Byb2R1Y3Rpb24nO1xuICAgIGNvbnN0IGNvbmZpZ3VyZWQgPSBnZW5lcmF0ZVdlYnBhY2tDb25maWcoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgd2VicGFjayhjb25maWd1cmVkLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgaWYoZXJyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBlcnIuZGV0YWlscyA/IGBcXG5cXHQke2Vyci5kZXRhaWxzfWAgOiAnJztcbiAgICAgICAgICAgICAgICB0aHJvdyBgV0VCUEFDSyBGQVRBTCBCVUlMRCBFUlJPUjogJHtlcnIudG9TdHJpbmcoKX0ke2RldGFpbHN9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHN0YXRzLnRvSnNvbigpO1xuXG4gICAgICAgICAgICBpZihzdGF0cy5oYXNFcnJvcnMoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBgV0VCUEFDSyBDT01QSUxBVElPTiBFUlJPUjogJHtpbmZvLmVycm9yc31gO1xuXG4gICAgICAgICAgICBpZihzdGF0cy5oYXNXYXJuaW5ncygpKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgV0VCUEFDSyBDT01QSUxBVElPTiBXQVJOSU5HOiAke2luZm8ud2FybmluZ3N9YCk7XG5cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5idWlsZC5kZXNjcmlwdGlvbiA9ICdZaWVsZHMgYSBwcm9kdWN0aW9uLXJlYWR5IHVucGFja2VkIGV4dGVuc2lvbiB2aWEgdGhlIGJ1aWxkIGRpcmVjdG9yeSc7XG5cbi8vICogQlVORExFLVpJUFxuXG5leHBvcnQgY29uc3QgYnVuZGxlWmlwID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRlbChbYCR7cGtnLm5hbWV9LSouemlwYF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBndWxwLnNyYygnYnVpbGQvKiovKicpLnBpcGUoemlwKGAke3BrZy5uYW1lfS0ke3BrZy52ZXJzaW9ufS56aXBgKSkucGlwZShndWxwLmRlc3QoJy4nKSk7XG4gICAgfSk7XG59O1xuXG5idW5kbGVaaXAuZGVzY3JpcHRpb24gPSAnQnVuZGxlcyB0aGUgYnVpbGQgZGlyZWN0b3J5IGludG8gYSB6aXAgYXJjaGl2ZSBmb3IgdXBsb2FkIHRvIHRoZSBDaHJvbWUgV2ViIFN0b3JlIGFuZCBlbHNld2hlcmUnO1xuXG4vLyAqIFdQREVWU0VSVlxuXG5leHBvcnQgY29uc3Qgd3BkZXZzZXJ2ID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ3VyZWQgPSBnZW5lcmF0ZVdlYnBhY2tDb25maWcoKTtcblxuICAgIE9iamVjdC5rZXlzKGNvbmZpZ3VyZWQuZW50cnkpLmZvckVhY2goZW50cnlLZXkgPT4gY29uZmlndXJlZC5lbnRyeVtlbnRyeUtleV0gPSBbXG4gICAgICAgIGB3ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50P2h0dHA6Ly8ke0RFVl9FTkRQT0lOVH06JHtERVZfUE9SVH1gLFxuICAgICAgICAnd2VicGFjay9ob3QvZGV2LXNlcnZlcidcbiAgICBdLmNvbmNhdChjb25maWd1cmVkLmVudHJ5W2VudHJ5S2V5XSkpO1xuXG4gICAgY29uZmlndXJlZC5wbHVnaW5zID0gKFtcbiAgICAgICAgbmV3IHdlYnBhY2suSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4oKSxcbiAgICAgICAgLi4uKGNvbmZpZ3VyZWQucGx1Z2lucyA/PyBbXSksXG4gICAgXTogQXJyYXk8YW55Pik7XG5cbiAgICBjb25zdCBwYWNrZXIgPSB3ZWJwYWNrKGNvbmZpZ3VyZWQpO1xuICAgIGNvbnN0IHNlcnZlciA9IG5ldyBXZWJwYWNrRGV2U2VydmVyKHBhY2tlciwge1xuICAgICAgICBkaXNhYmxlSG9zdENoZWNrOiB0cnVlLFxuICAgICAgICBob3Q6IHRydWUsXG4gICAgICAgIGNvbnRlbnRCYXNlOiBqb2luUGF0aChfX2Rpcm5hbWUsIHBhdGhzLmJ1aWxkKSxcbiAgICAgICAgaGVhZGVyczogeyAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonIH0sXG4gICAgICAgIHB1YmxpY1BhdGg6IGBodHRwOi8vJHtERVZfRU5EUE9JTlR9OiR7REVWX1BPUlR9L2AsXG4gICAgICAgIHNvY2tIb3N0OiBERVZfRU5EUE9JTlQsXG4gICAgICAgIHNvY2tQb3J0OiBERVZfUE9SVFxuICAgIH0pO1xuXG4gICAgc2VydmVyLmxpc3RlbihERVZfUE9SVCwgJzAuMC4wLjAnLCBlcnIgPT4geyBpZihlcnIpIHRocm93IGBXRUJQQUNLIERFViBTRVJWRVIgRVJST1I6ICR7ZXJyfWAgfSk7XG59O1xuXG53cGRldnNlcnYuZGVzY3JpcHRpb24gPSAnTGF1bmNoZXMgdGhlIFdlYnBhY2sgRGV2ZWxvcG1lbnQgU2VydmVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzJztcbiJdfQ==