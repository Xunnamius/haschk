"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = exports.wpdevserv = exports.cleanBuild = exports.cleanTypes = exports.regenerate = void 0;

require("source-map-support/register");

var _fs = require("fs");

var _util = require("util");

var _gulp = _interopRequireDefault(require("gulp"));

var _gulpTap = _interopRequireDefault(require("gulp-tap"));

var _del = _interopRequireDefault(require("del"));

var _fancyLog = _interopRequireDefault(require("fancy-log"));

var _parseGitignore = _interopRequireDefault(require("parse-gitignore"));

var _core = require("@babel/core");

var _path = require("path");

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _webpack2 = _interopRequireDefault(require("./webpack.config"));

var _documentation = _interopRequireDefault(require("documentation"));

var _streamArray = _interopRequireDefault(require("stream-array"));

var _vinylFs = _interopRequireDefault(require("vinyl-fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

require('dotenv').config();

const {
  WEBPACK_PORT,
  DEV_ENDPOINT
} = process.env;
if (typeof WEBPACK_PORT !== 'string') throw new TypeError('WEBPACK_PORT is improperly defined');
if (typeof DEV_ENDPOINT !== 'string') throw new TypeError('DEV_ENDPOINT is improperly defined');
const DEV_PORT = parseInt(WEBPACK_PORT, 10);
const paths = {};
paths.flowTyped = 'flow-typed';
paths.flowTypedGitIgnore = `${paths.flowTyped}/.gitignore`;
paths.build = `build`;
paths.buildGitIgnore = `${paths.build}/.gitignore`;
paths.configs = 'config';
paths.docs = 'docs/documentation';
paths.packageJson = 'package.json';
paths.launchJson = '.vscode/launch.json';
paths.launchJsonDist = '.vscode/launch.dist.json';
paths.env = '.env';
paths.envDist = 'dist.env';
paths.gitProjectDir = '.git';
paths.gitIgnore = '.gitignore';
paths.packageLockJson = 'package-lock.json';
paths.build = `${__dirname}/build`;
paths.regenTargets = [`${paths.configs}/*.js`];

const generateDocs = () => {
  let entryPaths = Object.values(_webpack2.default.entry).slice().map(entry => {
    var _entry$slice$pop;

    return (_entry$slice$pop = entry.slice().pop()) !== null && _entry$slice$pop !== void 0 ? _entry$slice$pop : "";
  });
  return _documentation.default.build(entryPaths, {
    shallow: true
  }).then(_documentation.default.formats.html).then(output => {
    (0, _streamArray.default)(output).pipe(_vinylFs.default.dest(paths.docs));
  }).catch(function (err) {
    console.log(err);
  });
};

const CLI_BANNER = `/**
* !!! DO NOT EDIT THIS FILE DIRECTLY !!!
* ! This file has been generated automatically. See the config/*.js version of
* ! this file to make permanent modifications!
*/\n\n`;
const readFileAsync = (0, _util.promisify)(_fs.readFile);

const cleanTypes = async () => {
  const targets = (0, _parseGitignore.default)((await readFileAsync(paths.flowTypedGitIgnore)));
  (0, _fancyLog.default)(`Deletion targets @ ${paths.flowTyped}/: "${targets.join('" "')}"`);
  (0, _del.default)(targets, {
    cwd: paths.flowTyped
  });
};

exports.cleanTypes = cleanTypes;
cleanTypes.description = `Resets the ${paths.flowTyped} directory to a pristine state`;

const cleanBuild = async () => {
  const targets = (0, _parseGitignore.default)((await readFileAsync(paths.buildGitIgnore)));
  (0, _fancyLog.default)(`Deletion targets @ ${paths.build}/: "${targets.join('" "')}"`);
  (0, _del.default)(targets, {
    cwd: paths.build
  });
};

exports.cleanBuild = cleanBuild;
cleanTypes.description = `Resets the ${paths.flowTyped} directory to a pristine state`;

const regenerate = () => {
  (0, _fancyLog.default)(`Regenerating targets: "${paths.regenTargets.join('" "')}"`);
  process.env.BABEL_ENV = 'generator';
  return _gulp.default.src(paths.regenTargets).pipe((0, _gulpTap.default)(file => file.contents = Buffer.from(CLI_BANNER + (0, _core.transformSync)(file.contents.toString(), {
    sourceFileName: (0, _path.relative)(__dirname, file.path)
  }).code))).pipe(_gulp.default.dest('.'));
};

exports.regenerate = regenerate;
regenerate.description = 'Invokes babel on the files in config, transpiling them into their project root versions';

const build = () => {
  process.env.NODE_ENV = 'production';
  return new Promise(resolve => {
    (0, _webpack.default)(_webpack2.default, (err, stats) => {
      if (err) {
        const details = err.details ? `\n\t${err.details}` : '';
        throw `WEBPACK FATAL BUILD ERROR: ${err}${details}`;
      }

      const info = stats.toJson();
      if (stats.hasErrors()) throw `WEBPACK COMPILATION ERROR: ${info.errors}`;
      if (stats.hasWarnings()) console.warn(`WEBPACK COMPILATION WARNING: ${info.warnings}`);
      resolve();
    });
  });
};

exports.build = build;
build.description = 'Yields a production-ready extension ready to be packaged';

const wpdevserv = () => {
  var _config$plugins;

  Object.keys(_webpack2.default.entry).forEach(entryKey => _webpack2.default.entry[entryKey] = [`webpack-dev-server/client?http://${DEV_ENDPOINT}:${DEV_PORT}`, 'webpack/hot/dev-server', _webpack2.default.entry[entryKey]]);
  _webpack2.default.plugins = [new _webpack.default.HotModuleReplacementPlugin(), ...((_config$plugins = _webpack2.default.plugins) !== null && _config$plugins !== void 0 ? _config$plugins : [])];
  const packer = (0, _webpack.default)(_webpack2.default);
  packer.hooks.afterCompile.tap('Generate Docs', () => {
    generateDocs();
  });
  const server = new _webpackDevServer.default(packer, {
    hot: true,
    contentBase: paths.build,
    headers: {
      'Access-Control-Allow-Origin': '*'
    }
  });
  server.listen(DEV_PORT, err => {
    if (err) throw `WEBPACK DEV SERVER ERROR: ${err}`;
  });
};

exports.wpdevserv = wpdevserv;
wpdevserv.description = 'Launches the Webpack Development Server for testing purposes';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmZpZy9ndWxwZmlsZS5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY29uZmlnIiwiV0VCUEFDS19QT1JUIiwiREVWX0VORFBPSU5UIiwicHJvY2VzcyIsImVudiIsIlR5cGVFcnJvciIsIkRFVl9QT1JUIiwicGFyc2VJbnQiLCJwYXRocyIsImZsb3dUeXBlZCIsImZsb3dUeXBlZEdpdElnbm9yZSIsImJ1aWxkIiwiYnVpbGRHaXRJZ25vcmUiLCJjb25maWdzIiwiZG9jcyIsInBhY2thZ2VKc29uIiwibGF1bmNoSnNvbiIsImxhdW5jaEpzb25EaXN0IiwiZW52RGlzdCIsImdpdFByb2plY3REaXIiLCJnaXRJZ25vcmUiLCJwYWNrYWdlTG9ja0pzb24iLCJfX2Rpcm5hbWUiLCJyZWdlblRhcmdldHMiLCJnZW5lcmF0ZURvY3MiLCJlbnRyeVBhdGhzIiwiT2JqZWN0IiwidmFsdWVzIiwiZW50cnkiLCJzbGljZSIsIm1hcCIsInBvcCIsImRvY3VtZW50YXRpb24iLCJzaGFsbG93IiwidGhlbiIsImZvcm1hdHMiLCJodG1sIiwib3V0cHV0IiwicGlwZSIsInZmcyIsImRlc3QiLCJjYXRjaCIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJDTElfQkFOTkVSIiwicmVhZEZpbGVBc3luYyIsInJlYWRGaWxlIiwiY2xlYW5UeXBlcyIsInRhcmdldHMiLCJqb2luIiwiY3dkIiwiZGVzY3JpcHRpb24iLCJjbGVhbkJ1aWxkIiwicmVnZW5lcmF0ZSIsIkJBQkVMX0VOViIsImd1bHAiLCJzcmMiLCJmaWxlIiwiY29udGVudHMiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJzb3VyY2VGaWxlTmFtZSIsInBhdGgiLCJjb2RlIiwiTk9ERV9FTlYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0YXRzIiwiZGV0YWlscyIsImluZm8iLCJ0b0pzb24iLCJoYXNFcnJvcnMiLCJlcnJvcnMiLCJoYXNXYXJuaW5ncyIsIndhcm4iLCJ3YXJuaW5ncyIsIndwZGV2c2VydiIsImtleXMiLCJmb3JFYWNoIiwiZW50cnlLZXkiLCJwbHVnaW5zIiwid2VicGFjayIsIkhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIiwicGFja2VyIiwiaG9va3MiLCJhZnRlckNvbXBpbGUiLCJ0YXAiLCJzZXJ2ZXIiLCJ3ZWJwYWNrRGV2U2VydmVyIiwiaG90IiwiY29udGVudEJhc2UiLCJoZWFkZXJzIiwibGlzdGVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFTQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBQSxPQUFPLENBQUMsUUFBRCxDQUFQLENBQWtCQyxNQUFsQjs7QUFFQSxNQUFNO0FBQUNDLEVBQUFBLFlBQUQ7QUFBZUMsRUFBQUE7QUFBZixJQUErQkMsT0FBTyxDQUFDQyxHQUE3QztBQUVBLElBQUcsT0FBT0gsWUFBUCxLQUF3QixRQUEzQixFQUNJLE1BQU0sSUFBSUksU0FBSixDQUFjLG9DQUFkLENBQU47QUFFSixJQUFHLE9BQU9ILFlBQVAsS0FBd0IsUUFBM0IsRUFDSSxNQUFNLElBQUlHLFNBQUosQ0FBYyxvQ0FBZCxDQUFOO0FBRUosTUFBTUMsUUFBUSxHQUFHQyxRQUFRLENBQUNOLFlBQUQsRUFBZSxFQUFmLENBQXpCO0FBRUEsTUFBTU8sS0FBSyxHQUFHLEVBQWQ7QUFFQUEsS0FBSyxDQUFDQyxTQUFOLEdBQWtCLFlBQWxCO0FBQ0FELEtBQUssQ0FBQ0Usa0JBQU4sR0FBNEIsR0FBRUYsS0FBSyxDQUFDQyxTQUFVLGFBQTlDO0FBQ0FELEtBQUssQ0FBQ0csS0FBTixHQUFlLE9BQWY7QUFDQUgsS0FBSyxDQUFDSSxjQUFOLEdBQXdCLEdBQUVKLEtBQUssQ0FBQ0csS0FBTSxhQUF0QztBQUNBSCxLQUFLLENBQUNLLE9BQU4sR0FBZ0IsUUFBaEI7QUFDQUwsS0FBSyxDQUFDTSxJQUFOLEdBQWEsb0JBQWI7QUFDQU4sS0FBSyxDQUFDTyxXQUFOLEdBQW9CLGNBQXBCO0FB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QXdCLDhEQUF4QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbi8vID8gVG8gcmVnZW5lcmF0ZSB0aGlzIGZpbGUgKGkuZS4gaWYgeW91IGNoYW5nZWQgaXQgYW5kIHdhbnQgeW91ciBjaGFuZ2VzIHRvXG4vLyA/IGJlIHBlcm1hbmVudCksIGNhbGwgYG5wbSBydW4gcmVnZW5lcmF0ZWAgYWZ0ZXJ3YXJkc1xuXG4vLyAhIEJlIHN1cmUgdGhhdCB0YXNrcyBleHBlY3RlZCB0byBydW4gb24gbnBtIGluc3RhbGwgKG1hcmtlZCBAZGVwZW5kZW50KSBoYXZlXG4vLyAhIGFsbCByZXF1aXJlZCBwYWNrYWdlcyBsaXN0ZWQgdW5kZXIgXCJkZXBlbmRlbmNpZXNcIiBpbnN0ZWFkIG9mXG4vLyAhIFwiZGV2RGVwZW5kZW5jaWVzXCIgaW4gdGhpcyBwcm9qZWN0J3MgcGFja2FnZS5qc29uXG5cbmltcG9ydCB7cmVhZEZpbGV9IGZyb20gJ2ZzJ1xuaW1wb3J0IHtwcm9taXNpZnl9IGZyb20gJ3V0aWwnXG5pbXBvcnQgZ3VscCBmcm9tICdndWxwJ1xuaW1wb3J0IHRhcCBmcm9tICdndWxwLXRhcCdcbmltcG9ydCBkZWwgZnJvbSAnZGVsJ1xuaW1wb3J0IGxvZyBmcm9tICdmYW5jeS1sb2cnXG5pbXBvcnQgcGFyc2VHaXRJZ25vcmUgZnJvbSAncGFyc2UtZ2l0aWdub3JlJ1xuaW1wb3J0IHt0cmFuc2Zvcm1TeW5jIGFzIGJhYmVsfSBmcm9tICdAYmFiZWwvY29yZSdcbmltcG9ydCB7cmVsYXRpdmUgYXMgcmVsUGF0aH0gZnJvbSAncGF0aCdcbmltcG9ydCB3ZWJwYWNrIGZyb20gJ3dlYnBhY2snXG5pbXBvcnQgd2VicGFja0RldlNlcnZlciBmcm9tICd3ZWJwYWNrLWRldi1zZXJ2ZXInXG5pbXBvcnQgY29uZmlnIGZyb20gJy4vd2VicGFjay5jb25maWcnXG5pbXBvcnQgZG9jdW1lbnRhdGlvbiBmcm9tICdkb2N1bWVudGF0aW9uJ1xuaW1wb3J0IHN0cmVhbUFycmF5IGZyb20gJ3N0cmVhbS1hcnJheSdcbmltcG9ydCB2ZnMgZnJvbSAndmlueWwtZnMnXG5cbnJlcXVpcmUoJ2RvdGVudicpLmNvbmZpZygpO1xuXG5jb25zdCB7V0VCUEFDS19QT1JULCBERVZfRU5EUE9JTlR9ID0gcHJvY2Vzcy5lbnY7XG5cbmlmKHR5cGVvZiBXRUJQQUNLX1BPUlQgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dFQlBBQ0tfUE9SVCBpcyBpbXByb3Blcmx5IGRlZmluZWQnKTtcblxuaWYodHlwZW9mIERFVl9FTkRQT0lOVCAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignREVWX0VORFBPSU5UIGlzIGltcHJvcGVybHkgZGVmaW5lZCcpO1xuXG5jb25zdCBERVZfUE9SVCA9IHBhcnNlSW50KFdFQlBBQ0tfUE9SVCwgMTApO1xuXG5jb25zdCBwYXRocyA9IHt9O1xuXG5wYXRocy5mbG93VHlwZWQgPSAnZmxvdy10eXBlZCc7XG5wYXRocy5mbG93VHlwZWRHaXRJZ25vcmUgPSBgJHtwYXRocy5mbG93VHlwZWR9Ly5naXRpZ25vcmVgO1xucGF0aHMuYnVpbGQgPSBgYnVpbGRgO1xucGF0aHMuYnVpbGRHaXRJZ25vcmUgPSBgJHtwYXRocy5idWlsZH0vLmdpdGlnbm9yZWA7XG5wYXRocy5jb25maWdzID0gJ2NvbmZpZyc7XG5wYXRocy5kb2NzID0gJ2RvY3MvZG9jdW1lbnRhdGlvbic7XG5wYXRocy5wYWNrYWdlSnNvbiA9ICdwYWNrYWdlLmpzb24nO1xucGF0aHMubGF1bmNoSnNvbiA9ICcudnNjb2RlL2xhdW5jaC5qc29uJztcbnBhdGhzLmxhdW5jaEpzb25EaXN0ID0gJy52c2NvZGUvbGF1bmNoLmRpc3QuanNvbic7XG5wYXRocy5lbnYgPSAnLmVudic7XG5wYXRocy5lbnZEaXN0ID0gJ2Rpc3QuZW52JztcbnBhdGhzLmdpdFByb2plY3REaXIgPSAnLmdpdCc7XG5wYXRocy5naXRJZ25vcmUgPSAnLmdpdGlnbm9yZSc7XG5wYXRocy5wYWNrYWdlTG9ja0pzb24gPSAncGFja2FnZS1sb2NrLmpzb24nO1xucGF0aHMuYnVpbGQgPSBgJHtfX2Rpcm5hbWV9L2J1aWxkYDtcblxucGF0aHMucmVnZW5UYXJnZXRzID0gW1xuICAgIGAke3BhdGhzLmNvbmZpZ3N9LyouanNgXG5dO1xuXG4vLyAqIGNvbnN0ZW50IGluIGNhc2UgYXQgZGlmZmVyZW50IHBvaW50cyBpbiB0aGUgY29tcGlsYXRpb24gY3ljbGUgd2Ugd2FudCB0byByZWdlbmVyYXRlIHRoZSBkb2NzLiAoUkEpXG5jb25zdCBnZW5lcmF0ZURvY3MgPSAoKSA9PiB7XG4gICAgbGV0IGVudHJ5UGF0aHMgPSBPYmplY3QudmFsdWVzKGNvbmZpZy5lbnRyeSkuc2xpY2UoKS5tYXAoZW50cnkgPT4geyByZXR1cm4gKGVudHJ5LnNsaWNlKCkucG9wKCkgPz8gXCJcIil9KTsgLy8gUmVtb3ZlcyBzcGVjaWFsIGVudHJ5IHBvaW50cyBmcm9tIFdlYlBhY2tcbiAgICByZXR1cm4gZG9jdW1lbnRhdGlvbi5idWlsZChlbnRyeVBhdGhzLCB7c2hhbGxvdzogdHJ1ZX0pXG4gICAgICAgIC50aGVuKGRvY3VtZW50YXRpb24uZm9ybWF0cy5odG1sKVxuICAgICAgICAudGhlbihvdXRwdXQgPT4ge1xuICAgICAgICAgICAgc3RyZWFtQXJyYXkob3V0cHV0KS5waXBlKHZmcy5kZXN0KHBhdGhzLmRvY3MpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSk7XG59O1xuXG5jb25zdCBDTElfQkFOTkVSID0gYC8qKlxuKiAhISEgRE8gTk9UIEVESVQgVEhJUyBGSUxFIERJUkVDVExZICEhIVxuKiAhIFRoaXMgZmlsZSBoYXMgYmVlbiBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS4gU2VlIHRoZSBjb25maWcvKi5qcyB2ZXJzaW9uIG9mXG4qICEgdGhpcyBmaWxlIHRvIG1ha2UgcGVybWFuZW50IG1vZGlmaWNhdGlvbnMhXG4qL1xcblxcbmA7XG5cbmNvbnN0IHJlYWRGaWxlQXN5bmMgPSBwcm9taXNpZnkocmVhZEZpbGUpO1xuXG4vLyAqIENMRUFOVFlQRVNcblxuY29uc3QgY2xlYW5UeXBlcyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB0YXJnZXRzID0gcGFyc2VHaXRJZ25vcmUoYXdhaXQgcmVhZEZpbGVBc3luYyhwYXRocy5mbG93VHlwZWRHaXRJZ25vcmUpKTtcblxuICAgIGxvZyhgRGVsZXRpb24gdGFyZ2V0cyBAICR7cGF0aHMuZmxvd1R5cGVkfS86IFwiJHt0YXJnZXRzLmpvaW4oJ1wiIFwiJyl9XCJgKTtcbiAgICBkZWwodGFyZ2V0cywge2N3ZDogcGF0aHMuZmxvd1R5cGVkfSk7XG59O1xuXG5jbGVhblR5cGVzLmRlc2NyaXB0aW9uID0gYFJlc2V0cyB0aGUgJHtwYXRocy5mbG93VHlwZWR9IGRpcmVjdG9yeSB0byBhIHByaXN0aW5lIHN0YXRlYDtcblxuLy8gKiBDTEVBTkJVSUxEXG5cbmNvbnN0IGNsZWFuQnVpbGQgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0cyA9IHBhcnNlR2l0SWdub3JlKGF3YWl0IHJlYWRGaWxlQXN5bmMocGF0aHMuYnVpbGRHaXRJZ25vcmUpKTtcblxuICAgIGxvZyhgRGVsZXRpb24gdGFyZ2V0cyBAICR7cGF0aHMuYnVpbGR9LzogXCIke3RhcmdldHMuam9pbignXCIgXCInKX1cImApO1xuICAgIGRlbCh0YXJnZXRzLCB7Y3dkOiBwYXRocy5idWlsZH0pO1xufTtcblxuY2xlYW5UeXBlcy5kZXNjcmlwdGlvbiA9IGBSZXNldHMgdGhlICR7cGF0aHMuZmxvd1R5cGVkfSBkaXJlY3RvcnkgdG8gYSBwcmlzdGluZSBzdGF0ZWA7XG5cbi8vICogUkVHRU5FUkFURVxuXG4vLyA/IElmIHlvdSBjaGFuZ2UgdGhpcyBmdW5jdGlvbiwgcnVuIGBucG0gcnVuIHJlZ2VuZXJhdGVgIHR3aWNlOiBvbmNlIHRvXG4vLyA/IGNvbXBpbGUgdGhpcyBuZXcgZnVuY3Rpb24gYW5kIG9uY2UgYWdhaW4gdG8gY29tcGlsZSBpdHNlbGYgd2l0aCB0aGUgbmV3bHlcbi8vID8gY29tcGlsZWQgbG9naWMuIElmIHRoZXJlIGlzIGFuIGVycm9yIHRoYXQgcHJldmVudHMgcmVnZW5lcmF0aW9uLCB5b3UgY2FuXG4vLyA/IHJ1biBgbnBtIHJ1biBnZW5lcmF0ZWAgdGhlbiBgbnBtIHJ1biByZWdlbmVyYXRlYCBpbnN0ZWFkLlxuY29uc3QgcmVnZW5lcmF0ZSA9ICgpID0+IHtcbiAgICBsb2coYFJlZ2VuZXJhdGluZyB0YXJnZXRzOiBcIiR7cGF0aHMucmVnZW5UYXJnZXRzLmpvaW4oJ1wiIFwiJyl9XCJgKTtcblxuICAgIHByb2Nlc3MuZW52LkJBQkVMX0VOViA9ICdnZW5lcmF0b3InO1xuXG4gICAgcmV0dXJuIGd1bHAuc3JjKHBhdGhzLnJlZ2VuVGFyZ2V0cylcbiAgICAgICAgLnBpcGUodGFwKGZpbGUgPT4gZmlsZS5jb250ZW50cyA9IEJ1ZmZlci5mcm9tKENMSV9CQU5ORVIgKyBiYWJlbChmaWxlLmNvbnRlbnRzLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGVOYW1lOiByZWxQYXRoKF9fZGlybmFtZSwgZmlsZS5wYXRoKVxuICAgICAgICB9KS5jb2RlKSkpXG4gICAgICAgIC5waXBlKGd1bHAuZGVzdCgnLicpKTtcbn07XG5cbnJlZ2VuZXJhdGUuZGVzY3JpcHRpb24gPSAnSW52b2tlcyBiYWJlbCBvbiB0aGUgZmlsZXMgaW4gY29uZmlnLCB0cmFuc3BpbGluZyB0aGVtIGludG8gdGhlaXIgcHJvamVjdCByb290IHZlcnNpb25zJztcblxuLy8gKiBCVUlMRCAocHJvZHVjdGlvbilcblxuY29uc3QgYnVpbGQ6IFByb21pc2U8dm9pZD4gPSAoKSA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB3ZWJwYWNrKGNvbmZpZywgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICAgIGlmKGVycilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gZXJyLmRldGFpbHMgPyBgXFxuXFx0JHtlcnIuZGV0YWlsc31gIDogJyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFdFQlBBQ0sgRkFUQUwgQlVJTEQgRVJST1I6ICR7ZXJyfSR7ZGV0YWlsc31gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmZvID0gc3RhdHMudG9Kc29uKCk7XG5cbiAgICAgICAgICAgIGlmKHN0YXRzLmhhc0Vycm9ycygpKVxuICAgICAgICAgICAgICAgIHRocm93IGBXRUJQQUNLIENPTVBJTEFUSU9OIEVSUk9SOiAke2luZm8uZXJyb3JzfWA7XG5cbiAgICAgICAgICAgIGlmKHN0YXRzLmhhc1dhcm5pbmdzKCkpXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXRUJQQUNLIENPTVBJTEFUSU9OIFdBUk5JTkc6ICR7aW5mby53YXJuaW5nc31gKVxuXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuYnVpbGQuZGVzY3JpcHRpb24gPSAnWWllbGRzIGEgcHJvZHVjdGlvbi1yZWFkeSBleHRlbnNpb24gcmVhZHkgdG8gYmUgcGFja2FnZWQnO1xuXG4vLyAqIFdQREVWU0VSVlxuXG5jb25zdCB3cGRldnNlcnYgPSAoKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoY29uZmlnLmVudHJ5KS5mb3JFYWNoKGVudHJ5S2V5ID0+IGNvbmZpZy5lbnRyeVtlbnRyeUtleV0gPSBbXG4gICAgICAgIGB3ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50P2h0dHA6Ly8ke0RFVl9FTkRQT0lOVH06JHtERVZfUE9SVH1gLFxuICAgICAgICAnd2VicGFjay9ob3QvZGV2LXNlcnZlcicsXG4gICAgICAgIGNvbmZpZy5lbnRyeVtlbnRyeUtleV1cbiAgICBdKTtcblxuICAgIGNvbmZpZy5wbHVnaW5zID0gW1xuICAgICAgICBuZXcgd2VicGFjay5Ib3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbigpLFxuICAgICAgICAuLi4oY29uZmlnLnBsdWdpbnMgPz8gW10pLFxuICAgIF07XG5cbiAgICBjb25zdCBwYWNrZXIgPSB3ZWJwYWNrKGNvbmZpZyk7XG5cbiAgICBwYWNrZXIuaG9va3MuYWZ0ZXJDb21waWxlLnRhcCgnR2VuZXJhdGUgRG9jcycsICgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVEb2NzKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgd2VicGFja0RldlNlcnZlcihwYWNrZXIsIHtcbiAgICAgICAgaG90OiB0cnVlLFxuICAgICAgICBjb250ZW50QmFzZTogcGF0aHMuYnVpbGQsXG4gICAgICAgIGhlYWRlcnM6IHsnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonfVxuICAgIH0pO1xuXG4gICAgc2VydmVyLmxpc3RlbihERVZfUE9SVCwgZXJyID0+IHsgaWYoZXJyKSB0aHJvdyBgV0VCUEFDSyBERVYgU0VSVkVSIEVSUk9SOiAke2Vycn1gIH0pO1xufTtcblxud3BkZXZzZXJ2LmRlc2NyaXB0aW9uID0gJ0xhdW5jaGVzIHRoZSBXZWJwYWNrIERldmVsb3BtZW50IFNlcnZlciBmb3IgdGVzdGluZyBwdXJwb3Nlcyc7XG5cbmV4cG9ydCB7cmVnZW5lcmF0ZSwgY2xlYW5UeXBlcywgY2xlYW5CdWlsZCwgd3BkZXZzZXJ2LCBidWlsZH07XG4iXX0=